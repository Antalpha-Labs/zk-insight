## Updates
### Perfect Zero-Knowledge PCPs for #P

这周有一些关于计算复杂性理论的讨论出来, Kurt Pan 也写了一个关于PSPACE的随笔。而这篇文章讨论了一个针对 #P 族编程语言的 ZK PCP 构造的问题。如果对PCP陌生的同学，可以看看链接2的文章，ZK PCP 即满足零知识性的PCP。

这篇论文基于 ZK sumcheck IOP 来实现：为了验证在$\{0,1\}^m$上的$∑F$（对于算术电路F），证明者发送一个随机的 mask $R$，使得$∑R = 0$；验证者选择一个随机数$c$；然后他们对$cF+R$ 进行$sumcheck$。

交互过程在这里很重要, 如果我们试图通过让证明者为多个不同的$c$发送$cF+R$的$sumcheck$证明来消除交互，那么零知识性将会丧失(因为sumcheck是线性的)。而论文利用了求和检查声明的置换不变性来打破这种线性关系。

这篇论文非常长，形式化的定义和定理也很多。


- [paper](https://arxiv.org/abs/2403.11941)
- [PCP Theorems](https://arxiv.org/abs/cs/0304038)

### Towards Verifiable FHE in Practice


- [paper](https://eprint.iacr.org/2024/451.pdf)



### BitVM ZK Verifier

BitVM 最近开源了他们的 ZK Verifier，以比特币上证明任何事情为目标，其主要流程如下：

1. 用 RISC0 客户端程序创建STARK证明
2. 将STARK证明包装成Groth16证明，并在在C语言中编写其对应的Groth16验证器
3. 将验证器编译为rv32i指令集，从而转化为BitVM指令集

就第二部来看, 似乎如果有更多的工具可以减少开发 verifer的工作会更靠。

- [ZK Verifier](https://github.com/chainwayxyz/bitvm-zk-verifier)


### Client-side proof generation

这篇文章探讨了用于证明私有函数正确执行的客户端证明生成，并解释了它与通用rollup的证明生成的区别。隐私保护的zk-rollup的证明生成与通用zk-rollup有很大的区别。

这篇文章比较简单易懂，对于zk入门学习者可以参考例子增加对 zk 的理解。笔者感兴趣的地方在于 Goblin Plonk（可能笔者之前没有了解过），他允许允许资源受限的证明者构建具有多层递归的zk-snark，其核心逻辑是将每个递归层的昂贵操作（如椭圆曲线操作）被推迟到最后一步，而不是在每个层次上执行。

- [Client-side proof generation](https://aztec.network/blog/client-side-proof-generation/)
- [Goblin Plonk](https://hackmd.io/@aztec-network/B19AA8812)
